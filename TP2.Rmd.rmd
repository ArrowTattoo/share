---
title: "TP2"
output: html_document
date: "2025-12-02"
---
前期准备(非必要)

```{r}
# 安装必要的包（如果尚未安装）
if(!require(ggplot2)) install.packages("ggplot2")
if(!require(factoextra)) install.packages("factoextra") # 非常适合PCA可视化

library(ggplot2)
library(factoextra)
```




第一题 不使用现成的函数进行PCA运算,并理解PCA背后的原理

1.加载数据并且提取数值型变量:

```{r}
data("iris")
X=iris[,1:4]
head(X)
```

2.数据的标准化 公式为各个元素减去平均值

```{r}
meanX = apply(X,2,mean)
X=as.matrix(X)
Xcenter = t(t(X)-meanX)
head(Xcenter)

```



缩放:用中心化的数据除以标准差

```{r}
varX=sqrt(apply(Xcenter^2,2,sum)/(nrow(X)-1))
XPCA=t(t(Xcenter)/varX)
head(XPCA)
```

3.计算协方差矩阵 需要用中心化矩阵与它的转置矩阵的乘积除以n-1

```{r}
covX = (t(Xcenter) %*% Xcenter) / (nrow(Xcenter) - 1)

covX

```

4.计算特征值和特征向量

```{r}
eigenRes = eigen(covX)
eigenValues = eigenRes$values
eigenVector = eigenRes$vector
print(eigenValues)
print(eigenVector)
```
eigen()可以直接算出特征值和特征向量



5. 计算解释方差比

```{r}
explaineVar= eigenValues/sum(eigenValues)
explainVarSum = sum(explaineVar)

print(explaineVar)
print(explainVarSum)
```
解释方差的比值 = 单个特征值 / 特征值之和


6.投影到第一因子平面并绘图
投影公式 Y = Xcenter * eigenVector

```{r}
Y = Xcenter %*% eigenVector
head(Y)

```

绘图
species 这个是作为种类在这里
```{r}
plotData = data.frame(PC1 = Y[,1],
                      PC2 = Y[,2],
                      Species = iris$Species)
plotData
```
```{r}
plot(plotData$PC1,plotData$PC2,
     col = plotData$Species,
     pch = 19,
     xlab = "PC1",
     ylab = "PC2",
     main = "PCA image")
```

第二题: 真实数据

1. 数据加载和预处理
```{r}
url <- "https://raw.githubusercontent.com/Tiwarim386/Glass_Identification/master/glass.data"
# 读取数据，注意 header = FALSE 因为原始数据没有列名
glass <- read.csv(url, header = FALSE)
head(glass)
```
```{r}
colnames(glass) = c("Id", "RI", "Na", "Mg", "Al", "Si", "K", "Ca", "Ba", "Fe", "Type")
head(glass)
```
去掉对数据分析无用的id
```{r}
glassData = glass[,2:11]

head(glassData)
```

画箱线图
las 代表着标签竖着写
```{r}
boxplot(glassData,las = 2, main = "glassData", col = "green")
```
计算协方差矩阵


```{r}
meanGlass = apply(glassData , 2 , mean)
meanGlass
```


```{r}
centerGlass = t(t(glassData)-meanGlass)
head(centerGlass)
```

计算协方差矩阵
```{r}
covMatricGlass = (t(centerGlass)%*%centerGlass)/(nrow(glassData)-1)
covMatricGlass
```
验证
```{r}
cov(glassData)
```
计算相关系数矩阵
cor函数,里面只放数据集可以返回一个线性关系矩阵
代表数据集中所有的变量两两之间的关系
```{r}
Rmatrix = cor(glassData)
round(Rmatrix,2)
```
5. 使用 prcomp 进行 PCA

```{r}
PCAglass = prcomp(glassData,center = TRUE , scale. = TRUE)
PCAglass
```

```{r}
head(PCAglass$x)
```



验证正交基 Orthonormal basis
先旋转矩阵,得到U
验证U*U'是不是等于 单位矩阵

```{r}
U = PCAglass$rotation

t(U)%*%U
```
关于 center 和 scale 参数
# center: 将数据平移，使均值为0。PCA必须基于中心化数据。
# scale: 将数据除以标准差，使方差为1。消除量纲影响（如RI只有0.00x的变化，而Mg有几各单位的变化）。

手动投影

```{r}
glassScale = scale(glassData,center = TRUE , scale = TRUE)
projectionGlass = glassScale %*% PCAglass$rotation
head(projectionGlass)
```
验证是否与pca$x一样
结构接近0就是一样

```{r}
diffAvecPcaX = max(abs(projectionGlass - PCAglass$x))
diffAvecPcaX
```
绘图

```{r}
plot(PCAglass$x[,1], PCAglass$x[,2],
     main = "GlassPCA", xlab = "PC1",ylab = "PC2")
text(PCAglass$x[,1],PCAglass$x[,2],labels = glass$Id,pos = 3,cex = 0.6)

```
第三题
碎石图(Scree Plot)
绘制特征值(variances)

```{r}
screeplot(PCAglass,type = "lines",main = "Scree Plot")
```


计算解释方差百分比
```{r}
eigVal=PCAglass$sdev^2
varpercent = (eigVal / sum(eigVal))*100
barplot(varpercent,main = "exp %")
```
在这里决定保留几个主成分
# 依据: 
# 1. Kaiser准则 (特征值 > 1)
# 2. 累积解释方差达到一定阈值 (如 80%)
# 3. 碎石图的"肘部" (Elbow)


```{r}
print(paste(sum(varpercent[1:3]),"%"))
```
biplot双标图
```{r}
biplot(PCAglass,cex=0.7,main="biplot")
```
# - 红色箭头代表原始变量。箭头方向相近表示正相关，相反表示负相关，垂直表示不相关。
# - 箭头越长，该变量在当前平面的解释度越高。
# - 黑色数字代表个体。


变量在第一平面的表现(Representation / Cos2)

求这个cos2

```{r}
cosvar = cor(glassData , PCAglass$x)^2
cosvar
cosvar[,1:2]
```

# 4. 个体的贡献 (Contribution)
# 贡献度 = (个体坐标^2) / (特征值 * n)

```{r}
n=nrow(glassData)
contrib = t(t(PCAglass$x^2) / (PCAglass$sdev*n))
head(contrib)
```

查看对PC1贡献最大的前五个个体

```{r}
glass$Id[order(contrib[,1],decreasing = TRUE)[1:5]]
```

5.是否排除某些个体?
# 如果某个体在 PC1 或 PC2 上极其远离中心（Outlier），且其贡献度极高，
# 它可能扭曲了主成分的方向。可以考虑排除后重做分析。

6. 投影是否反映了预期相似性？


```{r}
plot(PCAglass$x[,1],PCAglass$x[,2],col = as.factor(glass$Type),pch=19,main="PCA colored by Glass Type")
legend("topright",legend = levels(as.factor(glass$Type)),col=1:7,pch = 19)
```














